////  MNSequenceNote.m//  NotationTest////  Created by Michael Norris on Sun Jun 15 2003.//  Copyright (c) 2003 __MyCompanyName__. All rights reserved.//// *** PLEASE NOTE: IMPORTANT *** //// *** ALL PITCHES ARE ZERO-BASED *** //// *** THUS, IN C Maj, 0 IS THE FIRST DEGREE *** //// *** OF THE SCALE: e.g. C. 1 IS D, 2 IS E, etc *** //#import "MNSequenceNote.h"#import "MNSequenceBar.h"#import "MNSequencePitch.h"//#import "NSMutableArrayAdditions.h"#import "MNKeySignature.h"#import "MNCommonFunctions.h"@implementation MNSequenceNote- (id)init {    self = [super init];    if (self) {        pitches = [[NSMutableArray alloc] init];        duration = 0;        visible = YES;        accidentalVisible = YES;    }    return self;}- (id)initWithDuration:(float)dur bar:(MNSequenceBar*)b {    self = [self init];    if (self) {        duration = dur;        bar = b;    }    if (b == nil) {        NSLog(@"Bar was nil in MNSequenceNote");    }    return self;}- (id)initWithPitch:(int)pchromaticAlteration:(int)c           duration:(float)dur                bar:(MNSequenceBar*)b{    if (b == nil) {        NSLog(@"Bar was nil in MNSequenceNote");    }    self = [self initWithDuration:dur bar:b];    if (self) {        pitches = [[NSMutableArray alloc] init];        [self addPitch:p chromaticAlteration:c];    }    return self;}- (void)addPitch:(int)p chromaticAlteration:(int)c {    MNSequencePitch	*pitch;    pitch = [[MNSequencePitch alloc] initWithPitch:p chromaticAlteration:c];    [pitches addObject:pitch];}- (void)setPitch:(int)p chromaticAlteration:(int)c {    [self clearPitches];    [self addPitch:p chromaticAlteration:c];}- (int)countPitches {    return [pitches count];}- (void)clearPitches {    [pitches removeAllObjects];}- (void)setPitches:(NSMutableArray*)p {            pitches = p;}- (void)copyPitchesFromNote:(MNSequenceNote*)seqNote {    int	i,nPitches,pitch,alt;        [self clearPitches];    nPitches = [seqNote countPitches];    for (i=0;i<nPitches;i++) {        pitch = [seqNote pitchAtIndex:i];        alt = [seqNote altAtIndex:i];        [self addPitch:pitch chromaticAlteration:alt];    }}- (MNSequenceNote *)copyWithZone:(NSZone *)zone {    MNSequenceNote	*note;    note = [[[self class] allocWithZone:zone] init];    if (note) {        [note setPitches:[[NSMutableArray alloc] initWithArray:pitches copyItems:YES]];        [note setDuration:[self duration]];    }    return note;}- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id __unsafe_unretained *)stackbuf count:(NSUInteger)len {    return [pitches countByEnumeratingWithState:state objects:stackbuf count:len];}/// ** ACCESSORS ** ///- (float)duration { return duration; }- (void)setDuration:(float)f { duration = f; }- (float)durationIncludingTies {	float			dur = duration;	BOOL			t = YES,rest = [self isARest];	MNSequenceNote	*note = self;		if (!tied && !rest) {		return duration;	}		while (t) {		// get the next note		note = [note nextNote];		if (note != nil) {			if (rest && ![note isARest]) {				return dur;			}			dur += [note duration];			if (!rest) t = [note tied];		} else {			t = NO;		}	}		return dur;}- (MNSequenceNote *)nextNote {	MNSequenceBar	*currBar;	int				i,n;		currBar = bar;    if (bar == nil) {        NSLog(@"Bar was nil in nextNote");    }	i = [[bar notes] indexOfObjectIdenticalTo:self];	n = [[bar notes] count];		if (i == n-1) {		currBar = [bar nextBar];		n = [[currBar notes] count];		if (n == 0) {			return nil;		}		return [[currBar notes] objectAtIndex:0];	}	return [[bar notes] objectAtIndex:i+1];}- (MNSequenceNote *)prevNote {	NSMutableArray	*notes;	int				i,n;	MNSequenceBar	*currBar;		notes = [bar notes];	currBar = bar;    if (bar == nil) {        NSLog(@"Bar was nil in prevNote");    }		i = [notes indexOfObjectIdenticalTo:self];	n = [notes count];		if (i==0) {		currBar = [bar prevBar];		if (currBar == nil) {			return nil;		}		notes = [currBar notes];		n = [notes count];		if (n == 0) {			return nil;		}		return [notes objectAtIndex:n-1];	}	return [notes objectAtIndex:i-1];	}- (float)timeStampInBar {	NSMutableArray	*notes;	int				i,n;	float			dur = 0;		notes = [bar notes];	n = [notes indexOfObjectIdenticalTo:self];		for (i=0;i<n;i++) {		dur += [(MNSequenceNote*)[notes objectAtIndex:i] duration];	}		return dur;}- (float)timeStampInSequence {	MNBaseSequence	*sequence=[bar sequence];	NSMutableArray	*notes,*bars;	int				i,n;	float			dur = 0;		bars = [sequence bars];	n = [bars indexOfObjectIdenticalTo:bar];	for (i=0;i<n;i++) {		dur += [(MNSequenceBar*)[bars objectAtIndex:i] duration];	}		notes = [bar notes];	n = [notes indexOfObjectIdenticalTo:self];		for (i=0;i<n;i++) {		dur += [(MNSequenceNote*)[notes objectAtIndex:i] duration];	}		return dur;}- (int)pitch {    if ([pitches count] > 0) {        return [[pitches objectAtIndex:0] pitch];    }    NSLog(@"Tried to get the pitch of a rest.");    return 0;}- (int)chromaticAlteration {    if ([pitches count]>0) {        return [[pitches objectAtIndex:0] chromaticAlteration];    }    NSLog(@"Tried to get the alteration of a rest.");    return 0;}- (int)highestPitch {    int highestPitch=0,i;        if ([pitches count]>0) {        highestPitch = [[pitches objectAtIndex:0] pitch];        for (i=1;i<[pitches count]; i++) {            if ([[pitches objectAtIndex:i] pitch] > highestPitch) {                highestPitch = [[pitches objectAtIndex:i] pitch];            }        }    }    return highestPitch;}- (int)lowestPitch {    int lowestPitch=0,i;        if ([pitches count]>0) {        lowestPitch = [[pitches objectAtIndex:0] pitch];        for (i=1; i<[pitches count];i++) {            if ([[pitches objectAtIndex:i] pitch] < lowestPitch) {                lowestPitch = [[pitches objectAtIndex:i] pitch];            }        }    }    return lowestPitch;}- (int)pitchAtIndex:(int)i { return [[pitches objectAtIndex:i] pitch]; }- (void)setPitchAtIndex:(int)i toPitch:(int)p { [[pitches objectAtIndex:i] setPitch:p]; }- (int)altAtIndex:(int)i { return [[pitches objectAtIndex:i] chromaticAlteration]; }- (void)setAltAtIndex:(int)i toAlt:(int)a { [[pitches objectAtIndex:i] setChromaticAlteration:a]; }- (int)altForPitch:(int)pitch keySig:(MNKeySignature *)ks {    int 		i,n;    MNSequencePitch	*tempPitch;    n = [pitches count];    for (i=0;i<n;i++) {        tempPitch = [pitches objectAtIndex:i];        if ([tempPitch pitch] == pitch) {            // make sure we add the non-key sig alteration (e.g. leading note in min)            return [tempPitch chromaticAlteration]+[ks nonKSAltForPitch:pitch];        }    }    return 99; // a kind of dummy return value signifying no pitch for this note}- (int)actualAccidental {    int 		alt, pitch, acc;    MNKeySignature	*ks;        alt = [self altAtIndex:0];    ks = [[bar sequence] keySignature];    pitch = [ks getDegree:[self pitchAtIndex:0]];    acc = [ks KSAltForPitch:pitch]+[ks nonKSAltForPitch:pitch]+alt;    return [ks actualAccidentalForPitch:pitch alt:alt];}- (BOOL)hasAccidental {    int 		alt,pitch;    MNKeySignature	*ks = [[bar sequence] keySignature];    MNSequenceNote	*tempNote;    BOOL		needsDisplay;    int			theIndex,tempAlt;    NSMutableArray	*notes = [bar notes];        if (!accidentalVisible || !visible || [self isARest]) return NO;    pitch = [self pitchAtIndex:0];    alt = [self altAtIndex:0] + [ks nonKSAltForPitch:pitch];    //return [self determineCorrectAccidentalForPitch:pitch    //                                 outAlteration:&alt    //                                  keySignature:ks];            // find this note    theIndex = [notes indexOfObjectIdenticalTo:self];    if (theIndex == NSNotFound) {        NSLog (@"Note couldn't find itself in its own bar!");    }        // assume that if it's altered it needs an accidental    // and if it's not then it doesn't    if (alt != 0) {        needsDisplay = YES;    } else {        needsDisplay = NO;    }        // now work backwards to find previous pitch    if (theIndex>0) {        for (theIndex=theIndex-1,tempAlt=99;theIndex>-1 && tempAlt == 99;theIndex--) {            tempNote = [notes objectAtIndex:theIndex];            tempAlt = [tempNote altForPitch:pitch                                     keySig:ks];            if (tempAlt != 99) {                if (alt == 0 && tempAlt != 0) {                    // the "natural" accidental must be shown                    needsDisplay = YES;                }                if (alt != 0 && alt == tempAlt) {                    // it's already this, so don't show accidental                    needsDisplay = NO;                }            }        }    }    return needsDisplay;}- (void)chromaticallyAlter:(int)i {    for (MNSequencePitch *pitch in pitches) [pitch setChromaticAlteration:[pitch chromaticAlteration]+i];}- (NSString *)description {    int i;    NSString *str = @"(";    MNSequencePitch	*pitch;    for (i=0;i<[pitches count];i++) {        pitch = [pitches objectAtIndex:i];        str = [str stringByAppendingString:[NSString stringWithFormat:@"(%i,%i)",[pitch pitch],[pitch chromaticAlteration]]];        if (i<[pitches count]-1) {            str = [str stringByAppendingString:@","];        }    }    return str;}- (BOOL)isARest { return [pitches count] == 0; }- (void)setAccidentalVisible:(int)b { accidentalVisible = b; }- (int)getAccidentalVisible {return accidentalVisible; }- (void)showAccidental { [self setAccidentalVisible:YES]; }- (void)hideAccidental { [self setAccidentalVisible:NO]; }- (void)setVisible:(BOOL)b { visible = b; }- (BOOL)visible { return visible; }- (void)hide { [self setVisible:NO]; }- (void)show { [self setVisible:YES]; }- (BOOL)tied { return tied; }- (BOOL)prevNoteIsTied {	MNSequenceNote	*prevNote;	prevNote = [self prevNote];	if (prevNote == nil) {		return NO;	}	return [prevNote tied];}- (void)setTied:(BOOL)b { tied = b; }- (void)removePitchAtIndex:(int)i { [pitches removeObjectAtIndex:i]; }- (void)setBar:(MNSequenceBar*)b { bar = b; }- (MNSequenceBar*)bar { return bar; }@end