////  MNBaseSequence.m//  NotationTest////  Created by Michael Norris on Sat Jun 14 2003.//  Copyright (c) 2003 __MyCompanyName__. All rights reserved.//#import "MNBaseSequence.h"#import "MNSequenceBar.h"#import "MNSequenceNote.h"#import "MNSequencePitch.h"#import "MNTimeSignature.h"#import "MNKeySignature.h"#import "MNMusicPlayer.h"#import "MNMusicSequence.h"#import "MNMusicTrack.h"#import "MNCommonFunctions.h"// ** THESE IMPORTS DISABLED FOR IOS DEMO ** ////#import "MNTimeStampedMIDIPacket.h"//#import "MNSystem.h"//#import "MNBar.h"//#import "MNNote.h"//#import "NSMutableArrayAdditions.h"//#import "MNMIDIClient.h"//#import "MNScoreView.h"#define kDetachAmount	0.05#define quantize(foo)   (round(foo*4.0)/4.0)@implementation MNBaseSequence- (id)init {    self = [super init];    if (self) {        MIDIChannel = 1;        bars = [[NSMutableArray alloc] init];        timeSignatures = [[NSMutableArray alloc] init];        keySignature = [[MNKeySignature alloc] initWithBasePitch:0 mode:kMajorMode];        tempo = 105;    }    return self;}- (id)initWithTimeSigEnum:(int)e             timeSigDenom:(int)d               keySigCode:(int)s                     mode:(int)m                     clef:(int)c {    MNTimeSignature	*timeSig;    self = [super init];    if (self) {        MIDIChannel = 1;        bars = [[NSMutableArray alloc] init];        timeSignatures = [[NSMutableArray alloc] init];        keySignature = [[MNKeySignature alloc] initWithSigCode:s mode:m];        timeSig = [[MNTimeSignature alloc] initWithEnum:e denom:d];        [timeSignatures addObject:timeSig];        clef = c;        tempo = [timeSig defaultTempo];    }    return self;}/* - (id)initWithTimeStampedMIDI:(NSMutableArray*)midi timeSigEnum:(int)e timeSigDenom:(int)d keySigCode:(int)s mode:(int)m clef:(int)c {  MNTimeSignature             *timeSig; int                         nNotes,i,j,pitch=0,alt=0,MIDIPitch; int                         prevAlt,prevPitch; MNTimeStampedMIDIPacket     *packet; float                       sTime,prevTime,fillDur,tempTime,duration,b,lastBarDur,beatDur; NSMutableArray              *beatStructure; int                         nDowns; BOOL                        inSameDownbeat; MNSequenceNote              *note; MNSequenceBar               *lastBar;  self = [super init]; if (self) { MIDIChannel = 1; bars = [[NSMutableArray alloc] init]; timeSignatures = [[NSMutableArray alloc] init]; keySignature = [[MNKeySignature alloc] initWithSigCode:s mode:m]; timeSig = [[MNTimeSignature alloc] initWithEnum:e denom:d]; beatStructure = [timeSig beamStructure]; [timeSignatures addObject:timeSig]; clef = c; tempo = [timeSig defaultTempo];  // how many notes int the time stamped MIDI? nNotes = [midi count];  // get first note if (nNotes > 0) { packet = [midi objectAtIndex:0];  // get start time and pitch sTime = [packet timeStamp]; sTime = quantize(sTime); MIDIPitch = [packet MIDINote];  // convert absolute pitch to relative pitch [keySignature convertMIDINote:MIDIPitch toPitch:&pitch chromaticAlteration:&alt];  // on first beat? if (sTime != 0) {  // ***** // ** FIX: IF sTime < 0  if (sTime > 0) { // fill in with rests tempTime = sTime; while (tempTime > 0) { if (tempTime > e) { [self addRestWithDuration:e]; tempTime -= e; } else { if (e == 6) { if (tempTime>3) { [self addRestWithDuration:3]; tempTime -= 3; } } if (e == 4) { if (tempTime>2) { [self addRestWithDuration:2]; tempTime-=2; } }  // ***** // ** FIX: ADD MORE TIME SIGS HERE (e.g 5 & 7)  if (tempTime > 1) { [self addRestWithDuration:1]; tempTime-=1; } if (tempTime > 0) { [self addRestWithDuration:tempTime]; tempTime = 0; } } } } }  // loop through each note for (i=1;i<=nNotes;i++) {  prevTime = sTime; prevPitch = pitch; prevAlt = alt;  // get note if (i==nNotes) { sTime = e + (floor(prevTime/e)*e); } else { packet = [midi objectAtIndex:i];  // get start time and pitch sTime = [packet timeStamp]; sTime = quantize(sTime); MIDIPitch = [packet MIDINote];  // convert absolute pitch to relative pitch [keySignature convertMIDINote:MIDIPitch toPitch:&pitch chromaticAlteration:&alt]; }   // find duration duration = sTime - prevTime;  // repeat until total dur == 0 if (duration > 0) { // off beat? if (prevTime != floor(prevTime)) { // is next note in same beat? if (floor(prevTime) == floor (sTime)) { //yes, then just add note, unless it's 0 duration [self addNoteWithPitch:pitch chromaticAlteration:alt duration:duration]; duration = 0; } else { // fill to next down beat fillDur = 1 - (prevTime - floor(prevTime)); note = [self addNoteWithPitch:pitch chromaticAlteration:alt duration:fillDur]; duration -= fillDur; if (duration>0) { [note setTied:YES]; } prevTime = prevTime+fillDur; } }  while (duration > 0) { // is next note in same bar? if (floor(sTime/e) != floor (prevTime/e)) { // NO fillDur = e - (prevTime - (floor(prevTime/e)*e)); note = [self addNoteWithPitch:pitch chromaticAlteration:alt duration:fillDur]; duration -= fillDur; if (duration>0) { [note setTied:YES]; } prevTime = prevTime+fillDur; } else { // is next note in same downbeat? inSameDownbeat = YES; b = floor(prevTime / e) * e; nDowns = [beatStructure count]; for (j=0;j<nDowns;j++) { beatDur = [[beatStructure objectAtIndex:j] intValue]; b += beatDur; if (beatDur > 1 && ((prevTime < b && sTime > b) || (prevTime >b && sTime < b))) { inSameDownbeat = NO; } }   if (inSameDownbeat) { //yes, then just add note, unless it's 0 duration if (duration>1 && duration != floor(duration) && duration != 1.5) { fillDur = floor(duration); } else { fillDur = duration; } note = [self addNoteWithPitch:pitch chromaticAlteration:alt duration:fillDur]; duration -= fillDur; if (duration>0) { [note setTied:YES]; } } else { // fill to next down beat b = floor(prevTime / e) * e; nDowns = [beatStructure count]; for (j=0;j<nDowns;j++) { if (b > prevTime) { fillDur = b - prevTime; note = [self addNoteWithPitch:pitch chromaticAlteration:alt duration:fillDur]; duration -= fillDur; prevTime = prevTime+fillDur; if (duration > 0) { [note setTied:YES]; } break; } b += [[beatStructure objectAtIndex:j] intValue]; } } } } } } }  // fill up with rests if ([bars count] > 0) { lastBar = [bars lastObject]; lastBarDur = [lastBar duration]; if (lastBarDur < e) { if (lastBarDur != floor(lastBarDur)) { fillDur = 1 - (lastBarDur - floor(lastBarDur)); [self addRestWithDuration:fillDur]; lastBarDur = floor(lastBarDur)+1; }  // add rest fillDur = e - lastBarDur;  while (fillDur > 0) {  if (e == 6) { if (fillDur>3) { [self addRestWithDuration:3]; fillDur -= 3; } } if (e == 4) { if (fillDur>2) { [self addRestWithDuration:2]; fillDur-=2; } }  // ***** // ** FIX: ADD MORE TIME SIGS HERE (e.g 5 & 7)  if (fillDur > 1) { [self addRestWithDuration:1]; fillDur-=1; } if (fillDur > 0) { [self addRestWithDuration:tempTime]; fillDur = 0; } } } } }     return self; } */- (id)initWithTimeSignature:(MNTimeSignature *)timeSig               keySignature:(MNKeySignature *)keySig                       clef:(int)c{    self = [super init];    if (self) {        MIDIChannel = 1;        bars = [[NSMutableArray alloc] init];        timeSignatures = [[NSMutableArray alloc] init];        keySignature = keySig;        [timeSignatures addObject:timeSig];        clef = c;        tempo = [timeSig defaultTempo];    }    return self;}- (id)initWithTimeSigEnum:(int)e timeSigDenom:(int)d basePitch:(int)s mode:(int)m clef:(int)c {    MNTimeSignature	*timeSig;    self = [super init];    if (self) {        MIDIChannel = 1;        bars = [[NSMutableArray alloc] init];        timeSignatures = [[NSMutableArray alloc] init];        keySignature = [[MNKeySignature alloc] initWithBasePitch:s mode:m];        timeSig = [[MNTimeSignature alloc] initWithEnum:e denom:d];        [timeSignatures addObject:timeSig];        clef = c;        tempo = [timeSig defaultTempo];    }    return self;}- (void)setKeySignatureFromSigCode:(int)sigCode {    [keySignature setSigCode:sigCode];}- (MNKeySignature*)keySignature { return keySignature; }- (MNTimeSignature *)timeSignature { return [timeSignatures objectAtIndex:0]; }- (MNSequenceBar*)newBar {    MNSequenceBar	*bar;    bar = [[MNSequenceBar alloc] initWithTimeSignature:[timeSignatures lastObject]                                              sequence:self];    // make sure it gets released when the bars array is released    [bars addObject:bar];    return bar;}- (MNSequenceBar*)newBarWithTimeSignatureEnum:(int)e denom:(int)d {    MNSequenceBar	*bar;    MNTimeSignature	*timeSig;    timeSig = [[MNTimeSignature alloc] initWithEnum:e denom:d];    [timeSignatures addObject:timeSig];    bar = [self newBar];    return bar;}- (MNSequenceNote *)addRestWithDuration:(float)dur {    // get the last bar    MNSequenceBar	*bar;    MNSequenceNote	*note;    MNTimeSignature	*timeSig;    float		currDur,dur1;    int			numBeats;    bar = [bars lastObject];    if (bar == nil) {        // no bars created yet!        bar = [self newBar];    }    timeSig = [bar timeSignature];    currDur = [bar duration];    numBeats = [timeSig timeSigEnum];    if (currDur >= numBeats) {        // create a new bar        bar = [self newBar];        currDur = [bar duration];    }    if (currDur + dur > numBeats) {        // problem is that the duration is greater than thisd bar        // so we'll have to split it up        // eventually add a tie here        dur1 = numBeats - currDur;        note = [bar addRestWithDuration:dur1];        bar = [self newBar];        dur -= dur1;        note = [bar addRestWithDuration:dur];    } else {        note = [bar addRestWithDuration:dur];    }    return note;}- (MNSequenceNote *)addNoteWithPitch:(int)pitch chromaticAlteration:(int)acc duration:(float)dur {    // get the last bar    MNSequenceBar		*bar;    MNSequenceNote		*note;    MNTimeSignature		*timeSig;    float				currDur,dur1;    int					numBeats,nBars,i;	BOOL				done;		nBars = [bars count];	currDur = numBeats = 0;	bar = nil;		for (i=0;(i<nBars) && (currDur >= numBeats);i++) {		bar = [bars objectAtIndex:i];		timeSig = [bar timeSignature];		currDur = [bar duration];		numBeats = [timeSig timeSigEnum];	}    if (bar == nil || currDur >= numBeats) {        // need a new bar!        bar = [self newBar];		timeSig = [bar timeSignature];		currDur = [bar duration];		numBeats = [timeSig timeSigEnum];    }		done = NO;		// NOTE TIED OVER BARLINE    if (currDur + dur > numBeats) {        // problem is that the duration is greater than thisd bar        // so we'll have to split it up        // eventually add a tie here        dur1 = numBeats - currDur;        note = [bar addNoteWithPitch:pitch chromaticAlteration:acc duration:dur1];		[note setTied:YES];		// check if there's already another bar		bar = [bar nextBar];		if (bar == nil) {			bar = [self newBar];		}        dur -= dur1;        note = [bar addNoteWithPitch:pitch chromaticAlteration:acc duration:dur];		done = YES;    }    	// tied over half bar	if (!done && (numBeats == 4) && (currDur < 2) && (currDur + dur > 2) && !(currDur == 1 && (dur == 2 || dur ==3)) && !(currDur == 0 && (dur == 3 || dur == 4))) {		dur1 = 2 - currDur;		note = [bar addNoteWithPitch:pitch chromaticAlteration:acc duration:dur1];		[note setTied:YES];        dur -= dur1;        note = [bar addNoteWithPitch:pitch chromaticAlteration:acc duration:dur];		done = YES;	}		if (!done && dur == 1.75) {		note = [bar addNoteWithPitch:pitch chromaticAlteration:acc duration:1];		[note setTied:YES];        note = [bar addNoteWithPitch:pitch chromaticAlteration:acc duration:0.75];		done = YES;	}		if (!done) {		note = [bar addNoteWithPitch:pitch chromaticAlteration:acc duration:dur];	}        return note;}- (MNSequenceNote*)addTriadOnDegree:(int)degree                          triadType:(int)m                          inversion:(int)inversion                            seventh:(BOOL)seventh                           duration:(float)dur {    MNSequenceNote	*note;    int			interval,i;    note = [self addNoteWithPitch:degree chromaticAlteration:0 duration:dur];    switch (m) {        case kDiatonicTriad:            [note addPitch:degree+2 chromaticAlteration:0];            [note addPitch:degree+4 chromaticAlteration:0];            break;        case kMajorTriad:            interval = [keySignature semitonesFromDegree:degree toDegree:degree+2];            switch (interval) {                case kMajorThirdInterval:                    [note addPitch:degree+2 chromaticAlteration:0];                    break;                case kMinorThirdInterval:                    [note addPitch:degree+2 chromaticAlteration:kRaised];                    break;                default:                    [note addPitch:degree+2 chromaticAlteration:kLowered];                    break;            }            interval = [keySignature semitonesFromDegree:degree toDegree:degree+4];            switch (interval) {                case kPerfectFifthInterval:                    [note addPitch:degree+4 chromaticAlteration:0];                    break;                case kTritoneInterval:                    [note addPitch:degree+4 chromaticAlteration:kRaised];                    break;                default:                    [note addPitch:degree+4 chromaticAlteration:kLowered];                    break;            }            break;        case kMinorTriad:            interval = [keySignature semitonesFromDegree:degree toDegree:degree+2];            switch (interval) {                case kMinorThirdInterval:                    [note addPitch:degree+2 chromaticAlteration:0];                    break;                case kMajorThirdInterval:                    [note addPitch:degree+2 chromaticAlteration:kLowered];                    break;                default:                    [note addPitch:degree+2 chromaticAlteration:kRaised];                    break;            }            interval = [keySignature semitonesFromDegree:degree toDegree:degree+4];            switch (interval) {                case kPerfectFifthInterval:                    [note addPitch:degree+4 chromaticAlteration:0];                    break;                case kTritoneInterval:                    [note addPitch:degree+4 chromaticAlteration:kRaised];                    break;                default:                    [note addPitch:degree+4 chromaticAlteration:kLowered];                    break;            }            break;        case kDiminishedTriad:            interval = [keySignature semitonesFromDegree:degree toDegree:degree+2];            switch (interval) {                case kMinorThirdInterval:                    [note addPitch:degree+2 chromaticAlteration:0];                    break;                case kMajorThirdInterval:                    [note addPitch:degree+2 chromaticAlteration:kLowered];                    break;                default:                    [note addPitch:degree+2 chromaticAlteration:kRaised];                    break;            }            interval = [keySignature semitonesFromDegree:degree toDegree:degree+4];            switch (interval) {                case kPerfectFifthInterval:                    [note addPitch:degree+4 chromaticAlteration:kLowered];                    break;                case kTritoneInterval:                    [note addPitch:degree+4 chromaticAlteration:0];                    break;                default:                    [note addPitch:degree+4 chromaticAlteration:kLowered];                    break;            }            break;    }    // add seventh    if (seventh) {        [note addPitch:degree+6 chromaticAlteration:0];    }    // do the inversion    if (inversion > 0) {        if (degree > 0) {            for (i=inversion;i<3+seventh;i++) {                [note setPitchAtIndex:i toPitch:[note pitchAtIndex:i]-7];            }        } else {            for (i=0;i<inversion;i++) {                [note setPitchAtIndex:i toPitch:[note pitchAtIndex:i]+7];            }        }    }    return note;}/* - (void)mergeWithScoreView:(MNScoreView*)scoreView { [self mergeWithScoreView:scoreView partNumber:0]; }  - (void)mergeWithScoreView:(MNScoreView*)scoreView partNumber:(int)p { [self mergeWithScoreView:scoreView fromBarNumber:0 partNumber:p];  }  - (void)mergeWithScoreView:(MNScoreView*)scoreView fromBarNumber:(int)b partNumber:(int)p { MNSystem	*system,*temp; int		i; temp = [[scoreView systems] objectAtIndex:0]; system = [scoreView newSystemWithKeySignature:keySignature clef:clef honourGroups:YES partNumber:p]; for (i=b;i<[bars count];i++) { system = [self attachToScoreView:scoreView barNumber:i system:system]; } }  - (MNSystem *)attachToScoreView:(MNScoreView*)scoreView barNumber:(int)i system:(MNSystem *)system { return [self attachToScoreView:scoreView barNumber:i system:system rhythmsOnly:NO]; }  - (MNSystem *)attachToScoreView:(MNScoreView*)scoreView barNumber:(int)i system:(MNSystem *)system rhythmsOnly:(BOOL)rhythmsOnly { int 		j,k,nPitches; MNSequenceBar	*seqBar; MNSequenceNote	*seqNote=nil,*nextNote; MNBar		*bar; MNNote		*note=nil; MNTimeSignature	*timeSig; float		loc,dur,prev,next; int			beamCode,n; BOOL		augDot;  if (system == NULL) { [scoreView clear]; system = [scoreView newSystemWithKeySignature:keySignature clef:clef]; } // get the bar seqBar = [bars objectAtIndex:i]; n = [seqBar countNotes]; timeSig = [seqBar timeSignature]; if (i>=[system countBars]) { bar = [system newBarWithTimeSignature:timeSig]; // NB: System may have changed system = [bar system]; } else { bar = [system barAtIndex:i]; } dur = 0; for (j=0,loc=0.0;j<n;j++) { if (seqNote!=nil) { if ([seqNote isARest]) { dur = 0; } } seqNote = [seqBar noteAtIndex:j]; // we need to keep track of beaming prev = dur; dur = [seqNote duration]; if (j+1<n) { nextNote = [seqBar noteAtIndex:j+1]; if ([nextNote isARest]) { next = 0; } else { next = [nextNote duration]; } } else { next = 0.0; } // get the "beam code": in other words, whether this note is at // the beginning or end or in the middle of a beam group if ([seqNote isARest]) { beamCode = kNoBeam; } else { beamCode = [timeSig beamCodeForDuration:dur nextDuration:next prevDuration:prev startTime:loc]; } // does this note require am augmentation dot? augDot = [timeSig durationNeedsAugmentationDot:dur]; // add first pitch nPitches = [seqNote countPitches]; if (nPitches == 0) { note = [bar addRestWithDuration:[seqNote duration] startTime:loc augmentationDot:augDot]; } else {  if (rhythmsOnly) { note = [bar addNoteWithPitch:6 chromaticAlteration:0 duration:[seqNote duration] startTime:loc startOfBeam:(beamCode & kStartOfBeam) endOfBeam:(beamCode & kEndOfBeam) inBeamGroup:(beamCode & kInBeamGroup) augmentationDot:augDot]; } else { note = [bar addNoteWithPitch:[seqNote pitchAtIndex:0] chromaticAlteration:[seqNote altAtIndex:0] duration:[seqNote duration] startTime:loc startOfBeam:(beamCode & kStartOfBeam) endOfBeam:(beamCode & kEndOfBeam) inBeamGroup:(beamCode & kInBeamGroup) augmentationDot:augDot]; for (k=1;k<nPitches;k++) { [note addPitch:[seqNote pitchAtIndex:k] chromaticAlteration:[seqNote altAtIndex:k]]; } } } // is it hidden?  [note setVisible:[seqNote visible]]; [note setAccidentalVisible:[seqNote getAccidentalVisible]]; [note setTied:[seqNote tied]]; loc += dur; } return system; }  - (void)attachToScoreView:(MNScoreView*)scoreView { [self attachToScoreView:scoreView partNumber:0]; }  - (void)attachRhythmsToScoreView:(MNScoreView*)scoreView { MNSystem	*system; int		i; [scoreView clear]; system = [scoreView newRhythmSystem]; for (i=0;i<[bars count];i++) { system = [self attachToScoreView:scoreView barNumber:i system:system rhythmsOnly:YES]; } }  - (void)attachToScoreView:(MNScoreView*)scoreView partNumber:(int)p { [self attachToScoreView:scoreView fromBarNumber:0 partNumber:p]; }  - (void)attachToScoreView:(MNScoreView*)scoreView fromBarNumber:(int)b partNumber:(int)p {  MNSystem	*system; int		i; [scoreView clear]; system = [scoreView newSystemWithKeySignature:keySignature clef:clef honourGroups:YES partNumber:p]; for (i=b;i<[bars count];i++) { system = [self attachToScoreView:scoreView barNumber:i system:system]; } }  - (void)attachToScoreViewWithoutStems:(MNScoreView*)scoreView { // create one bar which holds all the notes in this base sequence int             nNotes,nBars,i,j,pitch,alt; MNSystem        *system; MNBar           *bar; MNTimeSignature *timeSig; MNSequenceBar   *seqBar; MNSequenceNote  *seqNote;  nNotes = [self countNotes]; [scoreView clear]; system = [scoreView newSystemWithKeySignature:keySignature clef:clef honourGroups:NO partNumber:0]; timeSig = [MNTimeSignature timeSignatureWithEnum:nNotes denom:4]; bar = [system newBarWithTimeSignature:timeSig]; [bar setStemsVisible:NO]; [bar setDisplayTimeSig:NO]; nBars = [bars count]; for (i=0;i<nBars;i++) { seqBar = [bars objectAtIndex:i]; nNotes = [seqBar countNotes]; for (j=0;j<nNotes;j++) { seqNote = [seqBar noteAtIndex:j]; pitch = [seqNote pitchAtIndex:0]; alt = [seqNote altAtIndex:0]; [bar addNoteWithPitch:pitch chromaticAlteration:alt duration:1.0]; } } } */// inSequence must be a valid MNMusicSequence object- (void)convertToMusicSequence:(MNMusicSequence *)inSequence {    [self convertToMusicSequence:inSequence                 stressDownbeats:NO];}- (void)convertToMusicSequence:(MNMusicSequence *)inSequence                dynamicProfile:(int)dynamicProfile {    [inSequence clear];    [self mergeWithMusicSequence:inSequence                  barsForNothing:0                 stressDownbeats:YES                       unpitched:NO                         channel:kPianoChannel                  dynamicProfile:dynamicProfile];}- (void)convertToMusicSequence:(MNMusicSequence*)inSequence               stressDownbeats:(BOOL)downs {    [self convertToMusicSequence:inSequence                 stressDownbeats:downs                       unpitched:NO];}- (void)convertToMusicSequence:(MNMusicSequence*)inSequence               stressDownbeats:(BOOL)downs                     unpitched:(BOOL)unpitched {    [inSequence clear];    [self mergeWithMusicSequence:inSequence                  barsForNothing:0                 stressDownbeats:downs                       unpitched:unpitched];}- (void)convertToMusicSequence:(MNMusicSequence*)inSequence                barsForNothing:(int)b               stressDownbeats:(BOOL)downs                     unpitched:(BOOL)unpitched {    [inSequence clear];    [self mergeWithMusicSequence:inSequence                  barsForNothing:b                 stressDownbeats:downs                       unpitched:unpitched];}- (void)convertToMusicSequence:(MNMusicSequence*)inSequence                     unpitched:(BOOL)unpitched {    [self convertToMusicSequence:inSequence                 stressDownbeats:NO                       unpitched:unpitched];}- (void)mergeWithMusicSequence:(MNMusicSequence *)inSequence                barsForNothing:(int)bfn{    [self mergeWithMusicSequence:inSequence                  barsForNothing:bfn                 stressDownbeats:NO];}- (void)mergeWithMusicSequence:(MNMusicSequence *)inSequence                barsForNothing:(int)bfn                     unpitched:(BOOL)unpitched {    [self mergeWithMusicSequence:inSequence                  barsForNothing:bfn                 stressDownbeats:NO                       unpitched:unpitched];}- (void)mergeWithMusicSequence:(MNMusicSequence *)inSequence {    [self mergeWithMusicSequence:inSequence                  barsForNothing:0];}- (void)mergeWithMusicSequence:(MNMusicSequence *)inSequence               stressDownbeats:(BOOL)downs {    [self mergeWithMusicSequence:inSequence                  barsForNothing:0                 stressDownbeats:downs];}- (void)mergeWithMusicSequence:(MNMusicSequence *)inSequence                barsForNothing:(int)bfn               stressDownbeats:(BOOL)downs {        [self mergeWithMusicSequence:inSequence                  barsForNothing:bfn                 stressDownbeats:downs                       unpitched:NO];}- (void)mergeWithMusicSequence:(MNMusicSequence *)inSequence                barsForNothing:(int)bfn               stressDownbeats:(BOOL)downs                       channel:(int)chan {    [self mergeWithMusicSequence:inSequence                  barsForNothing:bfn                 stressDownbeats:downs                       unpitched:NO                         channel:chan];}- (void)mergeWithMusicSequence:(MNMusicSequence *)inSequence                barsForNothing:(int)bfn               stressDownbeats:(BOOL)downs                     unpitched:(BOOL)unpitched {        [self mergeWithMusicSequence:inSequence                  barsForNothing:bfn                 stressDownbeats:downs                       unpitched:unpitched                         channel:kPianoChannel];}- (void)mergeWithMusicSequence:(MNMusicSequence *)inSequence                barsForNothing:(int)bfn               stressDownbeats:(BOOL)downs                     unpitched:(BOOL)unpitched                       channel:(int)chan {        [self mergeWithMusicSequence:inSequence                  barsForNothing:bfn                 stressDownbeats:downs                       unpitched:unpitched                         channel:kPianoChannel                  dynamicProfile:kNoDynamics];    }- (void)mergeWithMusicSequence:(MNMusicSequence *)inSequence                barsForNothing:(int)bfn               stressDownbeats:(BOOL)downs                     unpitched:(BOOL)unpitched                       channel:(int)chan                dynamicProfile:(int)dynamicProfile{        MNMusicTrack	*track;    MNTimeSignature	*timeSig;    MNSequenceBar	*seqBar;    MNSequenceNote	*seqNote;    float			timeLoc,dur,totalDur,ratio;    int				i,j,k,n,MIDIPitch,vel,channel;    float			inBarDur,barDur,addDur;    BOOL			tiedFromPrev = NO;    float 			dyn1Start, dyn1End, dyn2Start, dyn2End;    int 			numSections;            if (dynamicProfile != kNoDynamics) {        switch (dynamicProfile) {                            case kPthenF:                numSections = 2;                dyn1Start = kQuietVel;                dyn1End = kQuietVel;                dyn2Start = kLoudVel;                dyn2End = kLoudVel;                break;            case kFthenP:                numSections = 2;                dyn1Start = kLoudVel;                dyn1End = kLoudVel;                dyn2Start = kQuietVel;                dyn2End = kQuietVel;                break;            case kPtoF:                numSections = 1;                dyn1Start = kQuietVel;                dyn1End = kLoudVel;                break;            case kFtoP:                numSections = 1;                dyn1Start = kLoudVel;                dyn1End = kQuietVel;                break;            case kFthenPtoF:                numSections = 2;                dyn1Start = kLoudVel;                dyn1End = kLoudVel;                dyn2Start = kQuietVel;                dyn2End = kLoudVel;                break;            case kFtoPthenF:                numSections = 2;                dyn1Start = kLoudVel;                dyn1End = kQuietVel;                dyn2Start = kLoudVel;                dyn2End = kLoudVel;                break;            case kPthenFtoP:                numSections = 2;                dyn1Start = kQuietVel;                dyn1End = kQuietVel;                dyn2Start = kLoudVel;                dyn2End = kQuietVel;                break;            case kPtoFthenP:                numSections = 2;                dyn1Start = kQuietVel;                dyn1End = kLoudVel;                dyn2Start = kQuietVel;                dyn2End = kQuietVel;                break;                        }            }    	// initialize variables	    // create a new track        if (unpitched) {        channel = kPercussionChannel;        track = [inSequence percussionTrack];    } else {        channel = chan;        track = [inSequence track];    }    // if there's just one key sig then check whether it's 6/8    if ([timeSignatures count] >0) {                timeSig = [timeSignatures objectAtIndex:0];        [inSequence setTempo:tempo];        timeLoc = [timeSig timeSigEnum]*bfn;    } else {        timeLoc =0.0;    }        	addDur = 0;    totalDur = [self duration];    int numBars = [bars count];    for (i=0;i<numBars;i++) {        seqBar = [bars objectAtIndex:i];        timeSig = [seqBar timeSignature];        barDur = [timeSig timeSigEnum];        n = [seqBar countNotes];		        for (j=inBarDur=0;j<n;j++) {            seqNote = [seqBar noteAtIndex:j];            dur = [seqNote duration];                                    if (dynamicProfile != kNoDynamics) {                ratio = pow(timeLoc/totalDur,0.75);                if (numSections == 1) {                    if (dyn1End == dyn1Start) {                        vel = dyn1Start;                    } else {                        vel = dyn1Start + (dyn1End - dyn1Start) * ratio;                    }                } else {                    if ((i == numBars/2-1 && inBarDur > 0) || i >= numBars/2) {                        if (dyn2End == dyn2Start) {                            vel = dyn2Start;                        } else {                            float dynRatio = 2.*(ratio-0.5);                            if (dynRatio < 0) dynRatio = 0;                                                        vel = dyn2Start + (dyn2End - dyn2Start) * dynRatio;;                        }                    } else {                        if (dyn1End == dyn1Start) {                            vel = dyn1Start;                        } else {                                                        float dynRatio = ratio * 2.25;                            if (dynRatio > 1) dynRatio = 1;                            vel = dyn1Start + (dyn1End - dyn1Start) * dynRatio;                        }                    }                }            }                        if (downs && j==0) {                vel *= 1.2;                if (vel > 127) vel = 127;            }                        // now add the note (if it's not a tie)            if (![seqNote isARest]) {                                if ([seqNote tied]) {                    addDur += dur;                    tiedFromPrev = YES;                } else {                    if (tiedFromPrev) {                        dur += addDur;                        addDur = 0;						tiedFromPrev = NO;                    }                    // walk through pitches, converting to MIDI pitch, and adding to track                    for (k=0;k<[seqNote countPitches];k++) {                                                if (unpitched) {                            MIDIPitch = kSnareDrumPitch;                        } else {                            MIDIPitch = [keySignature MIDIPitchWithPitch:[seqNote pitchAtIndex:k]                                                     chromaticAlteration:[seqNote altAtIndex:k]];                        }                        [track newMIDINote:MIDIPitch                                   channel:channel                                  velocity:vel                                    atTime:timeLoc                                  duration:dur-kDetachAmount];                    }                }            }            if (![seqNote tied]) {                timeLoc+=dur;                inBarDur+=dur;            }        }    }}- (MNSequenceNote *)setNote:(int)index                    toPitch:(int)pitch        chromaticAlteration:(int)alt{    MNSequenceNote	*seqNote;    MNSequenceBar	*seqBar=nil;    int			i,noteIndex=0,noteAcc=0;    BOOL		keepLooping = YES;    if ([bars count] > 0) {        for (i=0;i<[bars count] && keepLooping;i++) {            seqBar = [bars objectAtIndex:i];            if (noteAcc+[seqBar countNotes]>index) {                noteIndex = index - noteAcc;                keepLooping = NO;            }        }        seqNote = [[seqBar notes] objectAtIndex:noteIndex];        if (seqNote) {            [seqNote clearPitches];            [seqNote addPitch:pitch chromaticAlteration:alt];        }        return seqNote;    }    return NULL;}- (MNSequenceNote *)setLastNoteToPitch:(int)pitch chromaticAlteration:(int)alt {    MNSequenceNote	*seqNote;    seqNote = [[[bars lastObject] notes] lastObject];    if (seqNote) {        [seqNote clearPitches];        [seqNote addPitch:pitch chromaticAlteration:alt];    }    return seqNote;}- (void) transposeDiatonic:(int)offset {    MNSequenceBar	*seqBar;    MNSequenceNote	*seqNote;    int		nBar,nNote,nPitches,i,j,k;    nBar = [bars count];    for (i=0;i<nBar;i++) {        seqBar = [bars objectAtIndex:i];        nNote = [seqBar countNotes];        for (j=0;j<nNote;j++) {            seqNote = [seqBar noteAtIndex:j];            nPitches = [seqNote countPitches];            for (k=0;k<nPitches;k++) {                [seqNote setPitchAtIndex:k toPitch:[seqNote pitchAtIndex:k]+offset];            }        }    }}- (MNBaseSequence*)copyWithZone:(NSZone *)zone {    MNBaseSequence	*copy;    copy = [[[self class] allocWithZone:zone] init];    if (copy) {        [copy setMIDIChannel:[self MIDIChannel]];        [copy setBars:[[NSMutableArray alloc] initWithArray:bars copyItems:YES]];        [copy setTimeSignatures:[timeSignatures copyWithZone:zone]];        [copy setKeySignature:[self keySignature]];        [copy setClef:[self clef]];    }    return copy;}- (MNBaseSequence*)copy {    MNBaseSequence	*copy;    copy = [[MNBaseSequence alloc] init];    if (copy) {        [copy setMIDIChannel:[self MIDIChannel]];        [copy setBars:[[NSMutableArray alloc] initWithArray:bars copyItems:YES]];        [copy setTimeSignatures:[timeSignatures copy]];        [copy setKeySignature:[self keySignature]];        [copy setClef:[self clef]];    }    return copy;}- (MNBaseSequence*)copyWithRange:(NSRange)range {    MNBaseSequence	*copy;    copy = [[MNBaseSequence alloc] init];    if (copy) {        [copy setMIDIChannel:[self MIDIChannel]];        [copy setBars:[[NSMutableArray alloc] initWithArray:[bars objectsAtIndexes:[NSIndexSet indexSetWithIndexesInRange:range]] copyItems:YES]];        [copy setTimeSignatures:[timeSignatures copy]];        [copy setKeySignature:[self keySignature]];        [copy setClef:[self clef]];    }    return copy;}- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id __unsafe_unretained *)stackbuf count:(NSUInteger)len {    return [bars countByEnumeratingWithState:state objects:stackbuf count:len];}- (MNSequenceNote*)getFirstNote {    MNSequenceBar	*bar;    if ([bars count] > 0) {        bar = [bars objectAtIndex:0];        if ([bar countNotes] > 0) {            return [bar noteAtIndex:0];        }    }    return nil;}- (MNMusicSequence*)generateClickTrack {    MNMusicSequence     *newSequence;    MNMusicTrack        *track;    MNTimeSignature     *tempTimeSig;    int                 nBars;    float               startTime;        newSequence = [self generateCountInBars:1];    track = [newSequence percussionTrack];    nBars = [self countBars];    // add a bar for nothing    tempTimeSig = [[self barAtIndex:0] timeSignature];    startTime = [tempTimeSig timeSigEnum];    for (MNSequenceBar *bar in bars) {        tempTimeSig = [bar timeSignature];        [track addClickTrackForTimeSignature:tempTimeSig                                   startTime:startTime];        startTime += [tempTimeSig timeSigEnum];    }    return newSequence;}- (MNMusicSequence*)generateCountInBars:(int)b {    MNMusicSequence	*newSequence;    MNMusicTrack	*track;    MNTimeSignature	*tempTimeSig;    int			i;    float		startTime;        tempTimeSig = [[self barAtIndex:0] timeSignature];    newSequence = [[MNMusicSequence alloc] initWithTempo:tempo];    track = [newSequence percussionTrack];    // add a bar for nothing    startTime = 0.0;    for (i=0;i<b;i++) {        [track addClickTrackForTimeSignature:tempTimeSig                                   startTime:startTime];        startTime += [tempTimeSig timeSigEnum];    }    return newSequence;}#define kBigMarginOfError	1.0#define kSmallMarginOfError	0.19/*  // COMPARE TWO BASE SEQUENCES TO SEE HOW ACCURATE THEY ARE. // WE ASSUME THAT KEY SIGNATURES AND TIME SIGNATURES ARE THE SAME - (int)markBaseSequenceForAccuracy:(MNBaseSequence *)sequence incorrectArray:(NSMutableArray **)incArray scoreView:(MNScoreView*)scoreView rhythmOnly:(BOOL)rhythmOnly pitchOnly:(BOOL)pitchOnly { int					i, j, x, nCorrectNotes=0; int					nNotes,nNotes2,maxAccPoints; MNSequenceNote		*seqNote,*enteredNote; MNSequenceBar		*seqBar,*enteredBar; int					pitch, alt, pitch2, alt2, index; float				dur, dur2, startTime; int					accuracy,totalAccPoints, accPercentage,nBars; MNNote				*scoreNote; MNBar				*scoreBar; BOOL				isARest, isARest2, hasAcc, hasAcc2, goodAcc; NSMutableArray		*tempIncArray;  *incArray = [[NSMutableArray alloc] init]; tempIncArray = [NSMutableArray arrayWithCapacity:5]; // initialize vars totalAccPoints = 0; // main loop nBars = [bars count];  for (i=0; i < nBars; i++) {  // get the correct bar seqBar = [bars objectAtIndex:i];  // get the entered bar enteredBar = [sequence barAtIndex:i]; scoreBar = [scoreView barAtIndex:i];  nNotes = [seqBar countNotes]; nNotes2 = [enteredBar countNotes];  // prime the temporary array to hold a bunch of flags // each flag refers to whether the note in the corresponding index is incorrect or not // we assume each note is incorrect until we have "found" its equivalent  [tempIncArray removeAllObjects]; for (x=0;x<nNotes2;x++) { [tempIncArray addObject:[NSNumber numberWithBool:YES]]; }  for (j=0;j<nNotes;j++) {  seqNote = [seqBar noteAtIndex:j]; accuracy = 0; isARest = [seqNote isARest]; nCorrectNotes ++;  // get details on the note we're looking for pitch = [seqNote pitch]; alt = [seqNote chromaticAlteration]; dur = [seqNote durationIncludingTies]; hasAcc = [seqNote hasAccidental]; startTime = [seqNote startTime];  // now locate a note that has the same start time enteredNote = [enteredBar findNoteAtStartTime:startTime];  if (enteredNote != nil) { if ([enteredNote visible]) { // ** CHECK FOR REST  // there is a note there, so check for duration pitch2 = [enteredNote pitch]; alt2 = [enteredNote chromaticAlteration]; dur2 = [enteredNote durationIncludingTies]; hasAcc2 = [enteredNote hasAccidental]; isARest2 = [enteredNote isARest];  if (isARest == isARest2) {  // how close are they (a little bit brute force this one - could be refined) if (rhythmOnly) { if (dur==dur2) accuracy = 2; } else { if (pitchOnly) { if (pitch==pitch2 && alt==alt2) { accuracy = 2; } } else { if (pitch==pitch2) { // check accidentals //Either the accidental must be right // or that it's hidden and the question is hidden too goodAcc = NO; if (!hasAcc && !hasAcc2) { goodAcc = YES; } if (alt == alt2) { goodAcc = YES; } if (goodAcc) accuracy ++; } if (dur==dur2) accuracy ++;  } } } } }  // if the note was present and correct then we unflag it if (accuracy == 2) { index = [[enteredBar notes] indexOfObjectIdenticalTo:enteredNote]; [tempIncArray replaceObjectAtIndex:index withObject:[NSNumber numberWithBool:NO]];  // also unflag any tied bits if (!isARest2) { while ([enteredNote tied] && index<(nNotes2-1)) { index++; enteredNote = [enteredBar noteAtIndex:index]; [tempIncArray replaceObjectAtIndex:index withObject:[NSNumber numberWithBool:NO]]; } } else { // or rest bits while ([enteredNote isARest] && index<nNotes2-1) { index++; enteredNote = [enteredBar noteAtIndex:index]; [tempIncArray replaceObjectAtIndex:index withObject:[NSNumber numberWithBool:NO]]; } if (![enteredNote isARest]) index --; } }  totalAccPoints += accuracy;  // only increment index2 if the startpoint of enteredNote is <= startpoint of seqnote // increment indexes until not tied over  // also unflag any tied bits if (!isARest) { while ([seqNote tied] && j<(nNotes-1)) { j++; seqNote = [seqBar noteAtIndex:j]; } } else { // or rest bits while ([seqNote isARest] && j<nNotes-1) { j++; seqNote = [seqBar noteAtIndex:j]; } if (![seqNote isARest]) j--; } }  // mark any extra notes as being incorrect for (x=0;x<nNotes2;x++) { if ([[tempIncArray objectAtIndex:x] boolValue] == YES) { scoreNote = [scoreBar noteAtIndex:x]; [*incArray addObject:scoreNote]; } } }  maxAccPoints = nCorrectNotes * 2; // 2 maximum points per note. 1 for pitch & alt, 1 for duration accPercentage = round(totalAccPoints * 100.0 / maxAccPoints); if (accPercentage < 0) accPercentage = 0; return accPercentage; }  - (int)markScoreViewForPitchOnly:(MNScoreView*)scoreView incorrectArray:(NSMutableArray **)incArray { int 		i, j, nCorrectNotes, nEnteredNotes; int			nNotes,maxAccPoints,enteredIndex; MNSequenceNote	*seqNote; MNNote              *enteredNote; MNSequenceBar	*seqBar; MNBar               *enteredBar; MNSystem            *system; int			pitch, alt, pitch2, alt2; int			accuracy,totalAccPoints, accPercentage,nBars; MNBar		*scoreBar;  *incArray = [[NSMutableArray alloc] init]; // initialize vars nCorrectNotes = [self countNotes]; system = [scoreView systemAtIndex:0]; enteredBar = [system barAtIndex:0]; nEnteredNotes = [enteredBar countNotes]; maxAccPoints = nCorrectNotes; // 2 maximum points per note. 1 for pitch & alt, 1 for duration totalAccPoints = 0; // main loop nBars = [bars count]; for (i=enteredIndex=0; i < nBars; i++) { seqBar = [bars objectAtIndex:i]; scoreBar = [scoreView barAtIndex:i]; nNotes = [seqBar countNotes]; for (j=0;j<nNotes;j++,enteredIndex++) { seqNote = [seqBar noteAtIndex:j]; if (enteredIndex>=nEnteredNotes) { accuracy = 0; } else { enteredNote = [enteredBar noteAtIndex:enteredIndex]; accuracy = 1; pitch = [seqNote pitch]; alt = [seqNote chromaticAlteration]; pitch2 = [enteredNote pitchAtIndex:0]; alt2 = [enteredNote altAtIndex:0]; // how close are they (a little bit brute force this one - could be refined) if (pitch!=pitch2) { accuracy --; } else { if (alt != alt2) { accuracy --; } } } if (!accuracy) { [*incArray addObject:enteredNote]; } totalAccPoints += accuracy; } // mark any extra notes as being incorrect }  if (nEnteredNotes>nCorrectNotes) totalAccPoints -= abs(nEnteredNotes - nCorrectNotes) * 2; accPercentage = round(totalAccPoints * 100.0 / maxAccPoints); if (accPercentage < 0) accPercentage = 0; return accPercentage; }   - (int)markTimeStampedMIDIForAccuracy:(NSMutableArray *)timeStampedMIDI incorrectArray:(NSMutableArray **)incArray scoreView:(MNScoreView*)scoreView { int						i, j, nCorrectNotes, nPlayedNotes, maxAccPoints, currentSearchIndex; float					startTime, timeStamp, distanceInTime; MNSequenceNote			*seqNote; MNKeySignature			*ks = [self keySignature]; int						pitch, alt, correctMIDIPitch, searchMIDIPitch; BOOL					foundNote,exitLoop; int						accuracy,totalAccPoints, accPercentage; MNTimeStampedMIDIPacket	*searchNote; MNNote					*scoreNote; *incArray = [[NSMutableArray alloc] init]; // initialize vars nCorrectNotes = [self countNotes]; nPlayedNotes = [timeStampedMIDI count]; maxAccPoints = nCorrectNotes * 5; // 5 maximum points per note currentSearchIndex = 0; startTime = 0.0; totalAccPoints = 0; // main loop for (i=0; i < nCorrectNotes; i++) { seqNote = [self noteAtIndex:i]; scoreNote = [scoreView noteAtIndex:i]; [*incArray addObject:scoreNote]; pitch = [seqNote pitch]; alt = [seqNote chromaticAlteration]; correctMIDIPitch = [ks MIDIPitchWithPitch:pitch chromaticAlteration:alt]; // search loop foundNote = NO; exitLoop = NO; accuracy = 0; for (j=currentSearchIndex;j<nPlayedNotes && !foundNote && !exitLoop;j++) { searchNote = [timeStampedMIDI objectAtIndex:j]; timeStamp = [searchNote timeStamp]; if (timeStamp > (startTime + kBigMarginOfError)) { exitLoop = YES; } else { if (timeStamp > (startTime - kBigMarginOfError)) { // check for pitch searchMIDIPitch = [searchNote MIDINote]; // found a match if (searchMIDIPitch == correctMIDIPitch) { // check time stamp foundNote = YES; if (fabs(timeStamp - startTime) < kSmallMarginOfError) { accuracy = 5; // only increase if right pitch at right time currentSearchIndex = j+1; [*incArray removeObject:scoreNote]; } else { distanceInTime = fabs(timeStamp - startTime); accuracy = 3 - ceil (3.0 * distanceInTime / kBigMarginOfError); } } } } } totalAccPoints += accuracy; startTime += [seqNote duration]; } if (nPlayedNotes>nCorrectNotes) totalAccPoints -= abs(nPlayedNotes - nCorrectNotes) * 5; accPercentage = round(totalAccPoints * 100.0 / maxAccPoints); if (accPercentage < 0) accPercentage = 0; return accPercentage; }  - (int)markTimeStampedMIDIForRhythms:(NSMutableArray *)timeStampedMIDI incorrectArray:(NSMutableArray **)incArray scoreView:(MNScoreView*)scoreView { int							i, j, x, nCorrectNotes, nPlayedNotes, maxAccPoints, currentSearchIndex; float						startTime, timeStamp, distanceInTime; MNSequenceNote				*seqNote; BOOL						foundNote,exitLoop; int							accuracy,totalAccPoints, accPercentage; MNTimeStampedMIDIPacket		*searchNote; MNNote						*scoreNote;  *incArray = [[NSMutableArray alloc] init]; // initialize vars nCorrectNotes = [self countNotesIgnoringTiesAndRests]; nPlayedNotes = [timeStampedMIDI count]; maxAccPoints = nCorrectNotes * 5; // 5 maximum points per note currentSearchIndex = 0; startTime = 0.0; totalAccPoints = 0; // main loop for (i=0,x=0,startTime=0; i < nCorrectNotes; i++,x++) { seqNote = [self noteAtIndex:x]; // skip rests and tied notes while ([seqNote isARest] || [seqNote prevNoteIsTied]) { x++; startTime += [seqNote duration]; seqNote = [self noteAtIndex:x]; } if (scoreView != nil) { scoreNote = [scoreView noteAtIndex:x]; if (scoreNote != nil) { [*incArray addObject:scoreNote]; } } else { [*incArray addObject:seqNote]; } // search loop foundNote = NO; exitLoop = NO; accuracy = 0; for (j=currentSearchIndex;j<nPlayedNotes && !foundNote && !exitLoop;j++) { searchNote = [timeStampedMIDI objectAtIndex:j]; timeStamp = [searchNote timeStamp]; if (timeStamp > (startTime + kBigMarginOfError)) { exitLoop = YES; } else { if (timeStamp > (startTime - kBigMarginOfError)) { foundNote = YES; if (fabs(timeStamp - startTime) < kSmallMarginOfError) { accuracy = 5; // only increase if right pitch at right time currentSearchIndex = j+1; if (scoreView != nil) { [*incArray removeObject:scoreNote]; } else { [*incArray removeObject:seqNote]; } } else { distanceInTime = fabs(timeStamp - startTime); accuracy = 3 - ceil (3.0 * distanceInTime / kBigMarginOfError); } } } } totalAccPoints += accuracy;  startTime += [seqNote duration]; } if (nPlayedNotes>nCorrectNotes) totalAccPoints -= abs(nPlayedNotes - nCorrectNotes) * 5; accPercentage = round(totalAccPoints * 100.0 / maxAccPoints); if (accPercentage < 0) accPercentage = 0; return accPercentage; }  */+ (void)convertMIDIPitchArrayToSequences:(NSMutableArray*)answerPitches                                 sigCode:(int)sigCode                                    mode:(int)mode                                duration:(float)dur                              RHSequence:(MNBaseSequence**)RHSequence                              LHSequence:(MNBaseSequence**)LHSequence{    MNSequenceNote	*LHNote=nil,*RHNote=nil;    MNKeySignature	*ks;    int			n,i,midiPitch,pitch=0,alt=0;    BOOL		addedToRH = NO, addedToLH = NO;    if (*RHSequence == nil) {        *RHSequence = [[MNBaseSequence alloc] initWithTimeSigEnum:4                                                     timeSigDenom:4                                                       keySigCode:sigCode                                                             mode:mode                                                             clef:kTrebleClef];        [*RHSequence newBar];    }    if (*LHSequence == nil) {        *LHSequence = [[MNBaseSequence alloc] initWithTimeSigEnum:4                                                     timeSigDenom:4                                                       keySigCode:sigCode                                                             mode:mode                                                             clef:kBassClef];        [*LHSequence newBar];    }    ks = [*RHSequence keySignature];    n = [answerPitches count];    if (n>0) {        for (i=0;i<n;i++) {            midiPitch = [[answerPitches objectAtIndex:i] intValue];            [ks convertMIDINote:midiPitch                        toPitch:&pitch            chromaticAlteration:&alt];            if (midiPitch >= kMiddleCMIDI) {                if (!addedToRH) {                    addedToRH = YES;                    RHNote = [*RHSequence addNoteWithPitch:pitch                                       chromaticAlteration:alt                                                  duration:dur];                } else {                    [RHNote addPitch:pitch                 chromaticAlteration:alt];                }            } else {                if (!addedToLH) {                    addedToLH = YES;                    LHNote = [*LHSequence addNoteWithPitch:pitch                                       chromaticAlteration:alt                                                  duration:dur];                } else {                    [LHNote addPitch:pitch                 chromaticAlteration:alt];                }            }        }    }    if (!addedToRH) {        [*RHSequence addRestWithDuration:dur];    }    if (!addedToLH) {        [*LHSequence addRestWithDuration:dur];    }}- (void)addLeadingNoteAlterations {    NSArray		*searchArray,*accArray,*searchStringArray;    int			i,j,nPatterns,nNotes,nAcc;    NSMutableString	*seqStr;    NSString		*accStr,*searchStr,*tempStr;    BOOL		strFound;    int			pitch,degree,nIndex;    int			startChar,endChar,len;    NSRange		foundRange;    MNSequenceNote	*note;        // these strings are formatted as a list of degrees to search for followed by ":"    // followed by the accidentals for each degree        nNotes = [self countNotes];    searchArray = @[@"5 6 0:1 0 0",@"6 5 6:0 1 0",@"6 5 4:-1 0 0",@"4 5 6:0 1 0"];            // now go through the sequence searching for the patterns    // to use the inbuilt string searching features we can convert base sequence to    // a list of degrees        seqStr = [NSMutableString stringWithCapacity:255];    for (i=0;i<nNotes;i++) {        note = [self noteAtIndex:i];        if (![note isARest] && ![note tied]) {            pitch = [note pitch];            degree = [self getDegree:pitch];        } else {            degree = 99;        }        // add as a string        [seqStr appendFormat:@"%i ",degree];    }        nPatterns = [searchArray count];    for (i=0;i<nPatterns;i++) {        tempStr = [searchArray objectAtIndex:i];        searchStringArray = [tempStr componentsSeparatedByString:@":"];        searchStr = [searchStringArray objectAtIndex:0];        accStr = [searchStringArray objectAtIndex:1];        accArray = [accStr componentsSeparatedByString:@" "];        nAcc = [accArray count];        // now search for searchStr;        strFound = YES;        startChar = 0; len = [seqStr length]; endChar = len-1;        while (strFound) {            if (len<1 || startChar >= endChar) {                                strFound = NO;                            } else {                foundRange = [seqStr rangeOfString:searchStr                                           options:NSCaseInsensitiveSearch                                             range:NSMakeRange(startChar,len)];                strFound = (foundRange.location != NSNotFound);                                if (strFound) {                    // we have a match - count the number of spaces before this                    nIndex = [[[seqStr substringToIndex:foundRange.location] componentsSeparatedByString:@" "] count]-1;                    for (j=0;j<nAcc;j++,nIndex++) {                        note = [self noteAtIndex:nIndex];                        [note setAltAtIndex:0                                      toAlt:[[accArray objectAtIndex:j] intValue]];                    }                    // add 1 for trailing space.                    startChar = foundRange.location+foundRange.length+1;                    len = endChar - startChar + 1;                } 	// strFound            }        } 	// while strFound    }		// searching for patterns}/*  - (void)addModulation { int 		nBars,nPossMods,modBar,nNotes,nModNotes; NSArray		*modsArrayMajor = @[@"3",@"13",@"23",@"34",@"43",@"53",@"123",@"243",@"323",@"453",@"543",@"5431",@"1231",@"3235"]; NSArray	*modsArrayMinor = @[@"0",@"02",@"20",@"40",@"012",@"120",@"202",@"420",@"0120",@"2012",@"4012"]; NSArray		*modsArray=nil; NSMutableArray	*possMods = [[NSMutableArray alloc] init]; MNSequenceBar	*bar,*bar2; MNSequenceNote	*note,*noteOne,*noteTwo; int			noteIndex,modIndex,pitch,startOctave,startDegree,i,degree; NSString		*myStr; int			mode = [keySignature mode],degreeOffset,ledg;  nBars = [bars count]; modBar = ceil(nBars/2)-1;  // grab as many notes in the mod bar as possible bar = [bars objectAtIndex:modBar]; nNotes = [bar countNotes]; nModNotes = (nNotes > 3)?4:nNotes; switch (mode) { case kMajorMode: modsArray = modsArrayMajor; break; case kHarmonicMinorMode: modsArray = modsArrayMinor; break; }  for (NSString *str in modsArray) if ([str length] == nModNotes) [possMods addObject:str];  noteIndex = nNotes - nModNotes; noteOne = [bar noteAtIndex:noteIndex]; if (noteIndex < 1) { bar2 = [bars objectAtIndex:modBar-1]; noteTwo = [bar2 noteAtIndex:[bar2 countNotes]-1]; } else { noteTwo = [bar noteAtIndex:noteIndex -1]; } int firstPitch = [noteTwo pitchAtIndex:0]; startDegree = [self getDegree:firstPitch]; startOctave = [self getOctave:firstPitch]; modIndex = 99; nPossMods = [possMods count]; for (i=0;i<nPossMods;i++) { degree = [[[possMods objectAtIndex:i] substringToIndex:1] intValue]; if (mode==kHarmonicMinorMode) degree = [self getDegree:degree-1]; if (startDegree == degree) modIndex = i; } if (modIndex == 99) modIndex = random()%nPossMods; myStr = [possMods objectAtIndex:modIndex];  // guess octave  // check ledger lines if (mode == kMajorMode) { degreeOffset = 0; pitch = 4+startOctave*7; } else { degreeOffset = -1; pitch = 3+degreeOffset+startOctave*7; } ledg = [keySignature pitchToNumLedgerLines:pitch clef:clef]; if (abs(ledg) > 1) { startOctave += (ledg<0)?1:-1; } for (i=0;i<nModNotes;i++,noteIndex++) { note = [bar noteAtIndex:noteIndex]; degree = [[myStr substringWithRange:NSMakeRange(i,1)] intValue]; degree += degreeOffset; pitch = degree+startOctave*7; [note setPitchAtIndex:0 toPitch:pitch]; [note setAltAtIndex:0 toAlt:0]; }  // search bar for alterations for (i=0;i<nNotes;i++) { note = [bar noteAtIndex:i]; degree = [self getDegree:[note pitchAtIndex:0]]; // raise fourth if (mode == kMajorMode && degree == 3) { [note setAltAtIndex:0 toAlt:1]; } if (mode == kHarmonicMinorMode && degree == 6) { [note setAltAtIndex:0 toAlt:-1]; } } bar = [bars objectAtIndex:modBar+1]; note = [bar noteAtIndex:0]; if (mode == kMajorMode) { pitch = 4+startOctave*7; } else { pitch = 3+degreeOffset+startOctave*7; } [note setPitchAtIndex:0 toPitch:pitch]; [note setAltAtIndex:0 toAlt:0]; }*/- (void)emphasiseFinal:(int)prob {    int 		nNotes;    MNSequenceNote	*note;    int			pitch,i,degree,octave;    BOOL		justDidIt = NO;        nNotes = [self countNotes];    for (i=0;i<nNotes;i++) {        if (random()%100<prob && i>0 && !justDidIt) {            note = [self noteAtIndex:i];            pitch = [note pitchAtIndex:0];            degree = [self getDegree:pitch];            octave = [self getOctave:pitch];            if (degree < 4) {                pitch = octave * 7;                justDidIt = YES;            }            if (degree > 4) {                pitch = (octave + 1) *7;                justDidIt = YES;            }            if (justDidIt) {                [note setPitch:pitch chromaticAlteration:0];            }        } else {            justDidIt = NO;        }    }}- (void)setPitchesTo:(int)p {	for (MNSequenceBar *bar in bars) {		for (MNSequenceNote *note in bar) {			if (![note isARest]) {				[note setPitchAtIndex:0 toPitch:p];				[note setAltAtIndex:0 toAlt:0];			}		}	}}- (int) countNotes {    int totalNotes = 0;    for (MNSequenceBar *bar in bars) totalNotes += [bar countNotes];    return totalNotes;}- (int) countNotesIgnoringTies {    int totalNotes = 0;    for (MNSequenceBar *bar in bars) totalNotes += [bar countNotesIgnoringTies];    return totalNotes;}- (int) countNotesIgnoringTiesAndRests {    int totalNotes = 0;    for (MNSequenceBar *bar in bars) totalNotes += [bar countNotesIgnoringTiesAndRests];    return totalNotes;}/// *** ACCESSORS *** ///- (void)setMIDIChannel:(int)m { MIDIChannel = m; }- (int)MIDIChannel { return MIDIChannel; }- (void)setBars:(NSMutableArray *)b {            bars = b;}- (NSMutableArray *)bars { return bars; }- (MNSequenceBar *)barAtIndex:(int)i {    if ([bars count] ==0) {        NSLog(@"Attempted to get a bar, when sequence has none.");        return nil;    } else {        return [bars objectAtIndex:i];    }}- (MNSequenceBar *)firstBar {    return [self barAtIndex:0];}- (MNSequenceBar *)lastBar {    if ([bars count] ==0) {        NSLog(@"Attempted to get a bar, when sequence has none.");        return nil;    } else {        return [bars lastObject];    }}- (MNSequenceNote *)noteAtIndex:(int)index {    int		count,cn,x;    count = 0;    for (MNSequenceBar *bar in bars) {        cn = [bar countNotes];        if (count+cn>index) {            x = (index-count);            return [bar noteAtIndex:x];        } else {            count += cn;        }    }    // bail    return [self lastNote];}- (MNSequenceNote *)firstNote {    MNSequenceBar *bar = [self firstBar];    if (bar) return [bar firstNote];    return nil;}- (MNSequenceNote *)lastNote {    MNSequenceBar *bar = [self lastBar];    if (bar) return [bar lastNote];    return nil;}- (int)countBars { return [bars count]; }- (void)setTimeSignatures:(NSMutableArray *)t { timeSignatures = t; }- (void)setTimeSigEnum:(int)e          timeSigDenom:(int)d {	MNTimeSignature *timeSig = [timeSignatures lastObject];	[timeSig setTimeSigEnum:e];	[timeSig setTimeSigDenom:d];}- (void)setKeySignature:(MNKeySignature *)k { keySignature = k; }- (void)setClef:(int)c { clef = c; }- (int)clef { return clef; }- (void)setTempo:(float)f { tempo = f; }- (float)tempo { return tempo; }- (float)duration {    float dur = 0.;    for (MNSequenceBar *b in bars) dur += [b duration];    return dur;}- (float)firstBarDurationInSeconds {    MNSequenceBar	*firstBar;    MNTimeSignature	*timeSig;    float		duration;        firstBar = [bars objectAtIndex:0];    timeSig = [firstBar timeSignature];    duration = [timeSig timeSigEnum] * 60.0/tempo;    return duration;}- (void)removeBars:(NSRange)range {	int i,m,n;		n = range.location + range.length - 1;	m = range.location;		for (i=n; i>=m; i--) [bars removeObjectAtIndex:i];}- (int)getDegree:(int)i { return [keySignature getDegree:i]; }- (int)getOctave:(int)i { return [keySignature getOctave:i]; }@end