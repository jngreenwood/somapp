////  MNCommonFunctions.m//  Aural Development X////  Created by Michael Norris on Wed Jun 25 2003.//  Copyright (c) 2003 __MyCompanyName__. All rights reserved.//#import "MNCommonFunctions.h"#import "MNKeySignature.h"//#import "MNScoreView.h"//#import "MNSystem.h"//#import "MNBar.h"//#import "MNNote.h"#import "MNBaseSequence.h"#import "MNSequenceNote.h"#import "MNSequenceBar.h"@implementation MNCommonFunctions+ (int)intervalCodeFromIntervalType:(int)iType intervalName:(int)iName{    return (iType << kIntervalTypeShifter) + (iName << kIntervalNameShifter);}+ (void)extractIntervalCode:(int)code               intervalType:(int*)intervalType               intervalName:(int*)intervalName{    if (intervalType != nil) *intervalType = (code >> kIntervalTypeShifter) & 0x0F;    if (intervalName != nil) *intervalName = (code >> kIntervalNameShifter) & 0x0F;}+ (int)intervalCodeFromChromatic:(int)interval {    int intervalType,intervalName;    int intervalTypes[13] = {0,kMin,kMaj,kMin,kMaj,kPerf,kAug,kPerf,kMin,kMaj,kMin,kMaj,kPerf};    int intervalNames[13] = {0,1,1,2,2,3,3,4,5,5,6,6,7};    int adjustedInterval;    adjustedInterval = abs(interval);    if (adjustedInterval == 0 || adjustedInterval > 12) return 0;    intervalType = intervalTypes[adjustedInterval];    intervalName = intervalNames[adjustedInterval];    return (intervalType << kIntervalTypeShifter) + (intervalName << kIntervalNameShifter);}+ (int)semitonesFromIntervalCode:(int)code {    int intervalQ,intervalN;    int majorST[8] = {0,2,4,5,7,9,11,12};    [self extractIntervalCode:code                 intervalType:&intervalQ                 intervalName:&intervalN];    switch (intervalQ) {        case kMaj:        case kPerf:            return majorST[intervalN];            break;        case kMin:        case kDim:            return majorST[intervalN]-1;            break;        case kAug:            return majorST[intervalN]+1;            break;    }    return 0;}+ (MNBaseSequence*)generateScaleWithSigCode:(int)sigCode                                       mode:(int)mode                               noteDuration:(float)dur                                       clef:(int)clef                                     octave:(int)octave{    int i;    MNBaseSequence	*sequence;    sequence = [[MNBaseSequence alloc] initWithTimeSigEnum:8                                              timeSigDenom:4                                                keySigCode:sigCode                                                      mode:mode                                                      clef:clef];    for (i=0;i<8;i++) {        [sequence addNoteWithPitch:i+octave*7               chromaticAlteration:0                          duration:dur];    }    return sequence;}+ (void)generateCadenceOfType:(int)cadence                      sigCode:(int)sigCode                         mode:(int)mode                 noteDuration:(float)dur                     leftHand:(MNBaseSequence**)LHBaseSequence                    rightHand:(MNBaseSequence**)RHBaseSequence {    MNSequenceNote	*seqNote;    int			i,nPitches,pitch;    *LHBaseSequence = [[MNBaseSequence alloc] initWithTimeSigEnum:4                                                     timeSigDenom:4                                                       keySigCode:sigCode                                                             mode:mode                                                             clef:kBassClef];    *RHBaseSequence = [[MNBaseSequence alloc] initWithTimeSigEnum:4                                                     timeSigDenom:4                                                       keySigCode:sigCode                                                             mode:mode                                                             clef:kTrebleClef];    switch (cadence) {        case kPerfectCadence:            // generate a second inversion dominant chord in the RH            [*RHBaseSequence addTriadOnDegree:-3                                    triadType:kDiatonicTriad                                    inversion:kSecondInversion                                      seventh:NO                                     duration:dur];            // add tonic            [*RHBaseSequence addTriadOnDegree:0                                    triadType:kDiatonicTriad                                    inversion:kFirstInversion                                      seventh:NO                                     duration:dur];            // generate V-I in bass            [*LHBaseSequence addNoteWithPitch:-10                          chromaticAlteration:0                                     duration:dur];            [*LHBaseSequence addNoteWithPitch:-14                          chromaticAlteration:0                                     duration:dur];            break;        case kPlagalCadence:            // 2nd inversion subdominant chord            [*RHBaseSequence addTriadOnDegree:-4                                    triadType:kDiatonicTriad                                    inversion:kSecondInversion                                      seventh:NO                                     duration:dur];            // add tonic            [*RHBaseSequence addTriadOnDegree:0                                    triadType:kDiatonicTriad                                    inversion:kFirstInversion                                      seventh:NO                                     duration:dur];            // generate IV-I in bass            [*LHBaseSequence addNoteWithPitch:-11                          chromaticAlteration:0                                     duration:dur];            [*LHBaseSequence addNoteWithPitch:-14                          chromaticAlteration:0                                     duration:dur];            break;        case kImperfectCadence:            // 1st inversion tonic chord            [*RHBaseSequence addTriadOnDegree:0                                    triadType:kDiatonicTriad                                    inversion:kFirstInversion                                      seventh:NO                                     duration:dur];            // add dom second            [*RHBaseSequence addTriadOnDegree:-3                                    triadType:kDiatonicTriad                                    inversion:kSecondInversion                                      seventh:NO                                     duration:dur];            // generate IV-I in bass            [*LHBaseSequence addNoteWithPitch:-14                          chromaticAlteration:0                                     duration:dur];            [*LHBaseSequence addNoteWithPitch:-10                          chromaticAlteration:0                                     duration:dur];            break;        case kInterruptedCadence:            // 2nd inversion dominant chord            [*RHBaseSequence addTriadOnDegree:-3                                    triadType:kDiatonicTriad                                    inversion:kSecondInversion                                      seventh:NO                                     duration:dur];            // 1st inv vi            seqNote = [*RHBaseSequence addTriadOnDegree:-2                                    triadType:kDiatonicTriad                                    inversion:kFirstInversion                                      seventh:NO                                     duration:dur];            // double third for imperfect cadence            nPitches = [seqNote countPitches];            for (i=0;i<nPitches;i++) {                pitch = [seqNote pitchAtIndex:i];                if ([*RHBaseSequence getDegree:pitch] == 5) {                    [seqNote setPitchAtIndex:i toPitch:pitch+2];                }            }            // generate IV-I in bass            [*LHBaseSequence addNoteWithPitch:-10                          chromaticAlteration:0                                     duration:dur];            [*LHBaseSequence addNoteWithPitch:-9                          chromaticAlteration:0                                     duration:dur];            break;                                        }}+ (void)replaceEndWithCadence:(int)cadenceType           trebleBaseSequence:(MNBaseSequence*)seq1             bassBaseSequence:(MNBaseSequence*)seq2 {    int			nNotes1,nNotes2,mode,sigCode;    MNSequenceNote	*trebNote1,*trebNote2,*bassNote1,*bassNote2;    MNBaseSequence	*tempTrebSeq,*tempBassSeq;    MNKeySignature	*ks = [seq1 keySignature];    MNSequenceBar	*bar;    mode = [ks mode];    sigCode = [ks sigCode];    nNotes1 = [seq1 countNotes];    nNotes2 = [seq2 countNotes];    trebNote1 = [seq1 noteAtIndex:nNotes1-2];    trebNote2 = [seq1 noteAtIndex:nNotes1-1];    bassNote1 = [seq2 noteAtIndex:nNotes2-2];    bassNote2 = [seq2 noteAtIndex:nNotes2-1];    // we want to make the treble note = bass note to avoid    // quaver cadences!    if ([bassNote1 duration] != [trebNote1 duration]) {        // this will only happen when bass note is encompassing        // two notes        // delete treb note        bar = [trebNote1 bar];        [bar deleteNote:trebNote1];        trebNote1 = [seq1 noteAtIndex:nNotes1-3];        [trebNote1 setDuration:[bassNote1 duration]];        //sorted    }        [self generateCadenceOfType:cadenceType                        sigCode:sigCode                           mode:mode                   noteDuration:1.0                       leftHand:&tempBassSeq                      rightHand:&tempTrebSeq];    // clear out existing notes    [trebNote1 copyPitchesFromNote:[tempTrebSeq noteAtIndex:0]];    [trebNote2 copyPitchesFromNote:[tempTrebSeq noteAtIndex:1]];    [bassNote1 copyPitchesFromNote:[tempBassSeq noteAtIndex:0]];    [bassNote2 copyPitchesFromNote:[tempBassSeq noteAtIndex:1]];        }        @end/*@implementation NSWindow (WindowCentering)- (void)centerOnScreen:(NSScreen *)screen{    NSRect visRect=[screen visibleFrame];    NSRect currentFrame=[self frame];    [self setFrameOrigin:NSMakePoint(floor(visRect.origin.x+(visRect.size.width-currentFrame.size.width)/2.0), floor(visRect.origin.y+(visRect.size.height-currentFrame.size.height)/1.5))];}- (void)showWithAnimation {    NSRect endRect=[self frame];    NSRect startRect=NSInsetRect(endRect,NSWidth(endRect)/2.1, NSHeight(endRect)/2.1);    [self setFrame:startRect display:NO animate:NO];    [self makeKeyAndOrderFront:self];    [self setFrame:endRect display:NO animate:YES];}@end*/@implementation NSMutableArray (BasicSorting)- (void)sort {    [self sortUsingSelector:@selector(compare:)];}@end/*@implementation NSMatrix (BetterSelectionMethods)- (NSArray *)MNSelectedCells {    NSPredicate *pred = [NSPredicate predicateWithFormat:@"state==%i",NSOnState];    return [[self cells] filteredArrayUsingPredicate:pred];}- (NSButtonCell *)MNSelectedCell {    NSEnumerator	*theEnumerator;    NSButtonCell	*theCell;    theEnumerator = [[self cells] objectEnumerator];    while ((theCell = [theEnumerator nextObject])) {        if ([theCell state] == NSOnState) {            return theCell;        }    }    return nil;}@end*/@implementation NSString (NSStringAdditions)- (BOOL)contains:(NSString*)str{	return [self rangeOfString:str].location != NSNotFound;}@end