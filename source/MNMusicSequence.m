////  MNMusicSequence.m//  MIDITest////  Created by Michael Norris on Wed Jan 29 2003.//  Copyright (c) 2003 Michael Norris. All rights reserved.//#import "MNMusicSequence.h"#import "MNMusicPlayer.h"#import "MNMusicTrack.h"//#import "MNMIDIClient.h"//#import "MNGlyphs.h"//#import "MNTimeStampedMIDIPacket.h"extern MNMusicPlayer	*gPlayer;extern AUNode           gPercussionNode;@implementation MNMusicSequence+ (MNMusicSequence *)newSequenceFromMIDIFile:(NSString*)MIDIFilePath {    //FSRef          fsref;    OSStatus        status;    CFURLRef pathRef;    MNMusicSequence *mySequence;        mySequence = [[self alloc] init];        pathRef = CFURLCreateWithString(NULL,(CFStringRef)CFBridgingRetain(MIDIFilePath),NULL);        status = MusicSequenceFileLoad ([mySequence sequence],pathRef,0,0);        if (status!=0) NSLog (@"MusicSequenceFileLoad failed: %d",(int)status);    [mySequence updateTracks];    [mySequence setTempo:80];    return mySequence;}/* - (void)exportSequenceToMIDIFilename:(NSString*)filename directory:(NSString*)dir { FSRef		inParentDirectory; OSStatus	status;  status = FSPathMakeRef((UInt8*)[dir fileSystemRepresentation], &inParentDirectory, NULL); status = MusicSequenceSaveMIDIFile( sequence,&inParentDirectory,(__bridge CFStringRef)filename,0,0); if (status!=0) NSLog (@"MusicSequenceSaveMIDIFile failed: %d",(int)status); }*/- (id)init {    OSStatus status;        self = [super init];    if (self) {        status = NewMusicSequence(&sequence);        if (status != 0) NSLog(@"NewMusicSequence: %d",(int)status);        tracks = [[NSMutableArray alloc] init];        tempo = 0;    }    return self;}// initWithTempo generates a MusicSequence and inserts a fresh MusicTrack together with an appropriate tempo event.-(id)initWithTempo:(float)bps {    OSStatus        status;    // int             i;    // AUNode          node;    //  MusicTrack      musicTrack;    //  MNMusicTrack    *theTrack;        self = [super init];    if (self) {        tempo = 0;        status = NewMusicSequence(&sequence);        if (status != 0) NSLog(@"NewMusicSequence: %d",(int)status);        tracks = [[NSMutableArray alloc] init];        [self setTempo:bps];        [self newTrack];        [self newTrack];    }    // for (i=0;i<[tracks count];i++) {    //   theTrack = [tracks objectAtIndex:i];    //   musicTrack = [theTrack track];    //    MusicTrackGetDestNode(musicTrack,&node);    //   NSLog(@"after init, track %i is %i",i,node);    //}    return self;}-(MNMusicTrack*)newTrack {    MNMusicTrack	*track;    // NSLog(@"New track");    track = [[MNMusicTrack alloc] initWithSequence:self];    if (track) {        [tracks addObject:track];    }    return track;}-(MusicSequence)sequence { return sequence; }-(int)trackCount {    OSStatus	status;    UInt32	numTracks;    status = MusicSequenceGetTrackCount (sequence, &numTracks);    if (status != 0) NSLog(@"MusicSequenceGetTrackCount: %d",(int)status);    return numTracks;}- (MNMusicTrack*)trackAtIndex:(int)i {    return [tracks objectAtIndex:i];}-(void)dealloc {    OSStatus	status;    //UInt32	numTracks;	[gPlayer stop];        status = MusicSequenceSetAUGraph(sequence,nil);    if (status != 0) NSLog(@"MusicSequenceSetAUGraph: %d",(int)status);    // must set sequence to null first    if (self == [gPlayer sequence]) [gPlayer setSequence:nil];    status = DisposeMusicSequence(sequence);    if (status != 0) NSLog(@"DisposeMusicSequence: %d",(int)status);    }- (void)setTempo:(float)bpm {    OSStatus 	status;    MusicTrack	tempoTrack;        if (tempo != 0) {        MusicSequenceGetTempoTrack(sequence, &tempoTrack);        status = MusicTrackClear (tempoTrack,0.0,kMusicTimeStamp_EndOfTrack);    }    [self newTempoEvent:bpm atTime:0.0];}-(void)newTempoEvent:(Float64)bpm atTime:(Float64)t {    OSStatus 	status;    MusicTrack	tempoTrack;    MusicSequenceGetTempoTrack(sequence, &tempoTrack);    status = MusicTrackNewExtendedTempoEvent(tempoTrack, t,bpm);    if (status != 0) NSLog (@"MusicTrackNewExtendedTempoEvent: %d",(int)status);    tempo = bpm;}- (void)clear {    int i;    for (i=0;i<[tracks count];i++) {        [[tracks objectAtIndex:i] clear];    }}- (void)play {    if ([gPlayer isPlaying]) [gPlayer stop];    [gPlayer setSequence:self];    [gPlayer start];}- (float)returnDuration{    return [gPlayer sequenceDurationInSeconds];}- (void)stop {    if ([gPlayer isPlaying]) {        [gPlayer stop];    }}/* - (void)syncWithView:(NSView*)view { if ([gPlayer isPlaying]) { [gPlayer stop]; } [gPlayer setSequence:self]; [gPlayer syncWithView:view]; }*/- (MNMusicTrack *)track { return [tracks objectAtIndex:0]; }- (MNMusicTrack *)percussionTrack {return [tracks objectAtIndex:1]; }- (float)tempo { return tempo; }- (void)mergePerformanceArray:(NSMutableArray*)myPerformanceArray              beatsForNothing:(int)b {    /*     int 			i,n;     MNTimeStampedMIDIPacket	*note,*nextNote;     float			theDur, nextTime;     MNMusicTrack		*theTrack = [tracks objectAtIndex:0];     n = [myPerformanceArray count];     for (i=0;i<n;i++) {     note = [myPerformanceArray objectAtIndex:i];     if (i<n-1) {     nextNote = [myPerformanceArray objectAtIndex:i+1];     } else {     nextNote = nil;     }     if (nextNote!=nil) {     nextTime = [nextNote timeStamp];     } else {     nextTime = [note timeStamp] + 2;     }     theDur = (nextTime - [note timeStamp]) * 0.95;     [theTrack newMIDINote:[note MIDINote]     channel:1     velocity:gLoudVel     atTime:[note timeStamp]+b     duration:theDur];     }     */}- (void)mergeWithMusicSequence:(MNMusicSequence*)seq {    OSStatus        status;    status = MusicTrackMerge([[self track] track],                             0.0,                             kMusicTimeStamp_EndOfTrack,                             [[seq track] track],                             0.0 );    if (status != 0) NSLog (@"MusicTrackMerge: %d",(int)status);    status = MusicTrackMerge([[self percussionTrack] track],                             0.0,                             kMusicTimeStamp_EndOfTrack,                             [[seq percussionTrack] track],                             0.0 );    if (status != 0) NSLog (@"MusicTrackMerge: %d",(int)status);}- (void)updateTracks {    int i;    UInt32 numTracks;    OSStatus    status;    MNMusicTrack    *track;    MusicTrack      theTrack;    [tracks removeAllObjects];    status = MusicSequenceGetTrackCount(sequence,&numTracks);    for (i=0;i<numTracks;i++) {        status = MusicSequenceGetIndTrack(sequence,i,&theTrack);        track = [MNMusicTrack newTrackWithSequence:self track:theTrack];            }}- (float)duration {    float 		longestDuration = 0.0;    int 		numTracks,i;    MNMusicTrack	*track;    numTracks = [tracks count];    for (i=0;i<numTracks;i++) {        track = [tracks objectAtIndex:i];        if ([track duration] > longestDuration) {            longestDuration = [track duration];        }    }    return longestDuration;}- (MNMusicSequence*)copyFromTimeStamp:(float)startTimeStamp                             duration:(float)duration                          keepCountIn:(BOOL)keepCountIn {    OSStatus            status;    MusicEventIterator  eventIterator;    Boolean             hasCurrentEvent;    MusicTimeStamp      timeStamp;    MusicEventType      eventType;    const void*               eventData;    UInt32              eventSize;        MNMusicSequence *newSequence = [[MNMusicSequence alloc] initWithTempo:tempo];    //float   status = MusicSequenceGetTrackCount(sequence,&numTracks);    float endTimeStamp = startTimeStamp + duration + musicStartTimestamp;        if (musicStartTimestamp != 0 && keepCountIn) {        // we have a count-in, so copy that        status = NewMusicEventIterator ([[self percussionTrack] track],&eventIterator);        MusicEventIteratorHasCurrentEvent (eventIterator, &hasCurrentEvent);        while (hasCurrentEvent) {            // is this a count-in?            status = MusicEventIteratorGetEventInfo (eventIterator,&timeStamp,&eventType,&eventData,&eventSize);            if (eventType == kMusicEventType_MIDINoteMessage) {                MIDINoteMessage *msg = (MIDINoteMessage *)eventData;                [[newSequence percussionTrack] newMIDINote:msg->note                                                   channel:msg->channel                                                  velocity:msg->velocity                                                    atTime:timeStamp                                                  duration:msg->duration];            }            MusicEventIteratorNextEvent (eventIterator);            MusicEventIteratorHasCurrentEvent (eventIterator, &hasCurrentEvent);        }    }        status = NewMusicEventIterator ([[self track] track],&eventIterator);    status = MusicEventIteratorSeek (eventIterator,startTimeStamp+musicStartTimestamp);    MusicEventIteratorHasCurrentEvent (eventIterator, &hasCurrentEvent);    while (hasCurrentEvent) {        // is this a count-in?        status = MusicEventIteratorGetEventInfo (eventIterator,&timeStamp,&eventType,&eventData,&eventSize);        if (timeStamp >= endTimeStamp) {            hasCurrentEvent = NO;        } else {            if (eventType == kMusicEventType_MIDINoteMessage) {                MIDINoteMessage *msg = (MIDINoteMessage *)eventData;                float newTimeStamp = timeStamp - startTimeStamp;                if (!keepCountIn) newTimeStamp -= musicStartTimestamp;                [[newSequence track] newMIDINote:msg->note                                         channel:msg->channel                                        velocity:msg->velocity                                          atTime:newTimeStamp                                        duration:msg->duration];            }            MusicEventIteratorNextEvent (eventIterator);            MusicEventIteratorHasCurrentEvent (eventIterator, &hasCurrentEvent);        }    }            /*  for (i=0;i<numTracks;i++){          status = MusicSequenceGetIndTrack(sequence,i,&theTrack);     MNTrack *newTrack = [[MNMusicTrack alloc] initWithSequence:newSequence];          }*/        return newSequence;}- (void)setPitchAtTimeStamp:(float)timeStampForPitchChange                toMIDIPitch:(UInt8)MIDIPitch {    OSStatus status;    MusicEventIterator  eventIterator;    Boolean hasCurrentEvent;    MusicTimeStamp      timeStamp;    MusicEventType      eventType;    const void*               eventData;    UInt32              eventSize;    MIDINoteMessage     msg;        status = NewMusicEventIterator ([[self track] track],&eventIterator);    status = MusicEventIteratorSeek (eventIterator,timeStampForPitchChange+musicStartTimestamp);    MusicEventIteratorHasCurrentEvent (eventIterator, &hasCurrentEvent);    if (hasCurrentEvent) {                status = MusicEventIteratorGetEventInfo (eventIterator,&timeStamp,&eventType,&eventData,&eventSize);        if (eventType == kMusicEventType_MIDINoteMessage) {            memcpy(&msg,eventData,eventSize);            msg.note = MIDIPitch;            MusicEventIteratorSetEventInfo (eventIterator,eventType,(const void*)&msg);        }    }    }-(void) changeNoteAtTimeStamp:(float)oldTimeStamp                  toTimeStamp:(float)newTimeStamp {    OSStatus status;    MusicEventIterator  eventIterator;    Boolean hasCurrentEvent;        status = NewMusicEventIterator ([[self track] track],&eventIterator);    status = MusicEventIteratorSeek (eventIterator,oldTimeStamp+musicStartTimestamp);    MusicEventIteratorHasCurrentEvent (eventIterator, &hasCurrentEvent);    if (hasCurrentEvent) {        MusicEventIteratorSetEventTime (eventIterator,newTimeStamp);    }}@synthesize musicStartTimestamp;@end